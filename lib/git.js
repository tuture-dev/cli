const fs = require('fs-extra');
const git = require('simple-git/promise')('.').silent(true);
const parser = require('gitdiff-parser');
const path = require('path');

const common = require('./common');

/**
 * Check cwd is a valid Git repo with at least one commit.
 */
async function checkGitEnv() {
  try {
    await git.log();
  } catch (err) {
    common.errAndExit(err.message);
  }
}

/**
 * Run arbitrary Git commands.
 * If exit status is not 0, log out stderr message and exit.
 * @param {Array} args arguments of command
 * @returns {String} stdout of running this git command
 */
async function runGitCommand(args) {
  let res = null;
  try {
    res = await git.raw(args);
  } catch (err) {
    common.errAndExit(err.message);
  }
  return res;
}

/**
 * Get an array of Git commit messages.
 * @returns {Array} Git commit messages
 */
async function getGitLogs() {
  const output = await runGitCommand(['log', '--oneline', '--no-merges']);
  return output.trim().split('\n');
}

function parseDiff(diff) {
  const files = parser.parse(diff);

  return files.map((file) => {
    const hunks = file.hunks.map(hunk => ({
      ...hunk,
      isPlain: false,
    }));

    return { ...file, hunks };
  });
}

/**
 * Get diff of a given commit.
 * @param {String} commit Commit ID
 * @returns {Array} Diff objects with attrs `file`, `explain`, and optional `collapse`
 */
async function getGitDiff(commit) {
  const output = await runGitCommand(['show', commit, '--name-only']);
  let changedFiles = output.split('\n\n').slice(-1)[0].split('\n');
  changedFiles = changedFiles.slice(0, changedFiles.length - 1);
  return changedFiles
    // don't track changes of tuture.yml
    .filter(file => file !== 'tuture.yml')
    .map((file) => {
      const diffFile = { file };
      if (common.shouldBeCollapsed(file)) {
        diffFile.collapse = true;
      }
      return diffFile;
    });
}

/**
 * Store diff of a given commit to a file.
 * @param {string[]} commits Array of commit hashes
 */
async function storeDiff(commits) {
  const diffPromises = commits.map(async (commit) => {
    const output = await runGitCommand(['show', commit]);
    const diffText = output.split('\n\n').slice(-1)[0];
    const diff = parseDiff(diffText);
    return { commit, diff };
  });

  Promise.all(diffPromises).then((diffs) => {
    fs.writeFileSync(
      path.join(common.TUTURE_ROOT, 'diff.json'),
      JSON.stringify(diffs),
    );
  });
}

/**
 * Generate Git hook for different platforms.
 */
function getGitHook() {
  let tuturePath = path.join(__dirname, '..', 'bin', 'tuture');
  if (process.platform === 'win32') {
    // replace all \ with / in the path, as is required in Git hook on windows
    // e.g. C:\foo\bar => C:/foo/bar
    tuturePath = tuturePath.replace(/\\/g, '/');
  }
  return `#!/bin/sh\n${tuturePath} reload\n`;
}

/**
 * Add post-commit Git hook for reloading.
 */
function appendGitHook() {
  const reloadHook = getGitHook();
  const hookPath = path.join('.git', 'hooks', 'post-commit');
  if (!fs.existsSync(hookPath)) {
    fs.writeFileSync(hookPath, reloadHook, { mode: 0o755 });
  } else if (!fs.readFileSync(hookPath).toString().includes('tuture reload')) {
    fs.appendFileSync(hookPath, reloadHook);
  }
}

/**
 * Remove Git hook for reloading.
 */
function removeGitHook() {
  const reloadHook = getGitHook();
  const hookPath = path.join('.git', 'hooks', 'post-commit');
  if (fs.existsSync(hookPath)) {
    const hook = fs.readFileSync(hookPath).toString();
    if (hook === reloadHook) {
      // Auto-generated by Tuture, so delete it.
      fs.removeSync(hookPath);
    } else {
      fs.writeFileSync(hookPath, hook.replace('tuture reload', ''));
    }
  }
}

exports.checkGitEnv = checkGitEnv;
exports.getGitLogs = getGitLogs;
exports.getGitDiff = getGitDiff;
exports.storeDiff = storeDiff;
exports.appendGitHook = appendGitHook;
exports.removeGitHook = removeGitHook;
